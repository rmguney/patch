#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(push_constant) uniform Constants {
    ivec3 src_dims;
    int src_level;
    ivec3 dst_dims;
    int dst_level;
    float falloff_factor;
    float energy_conserve;
    int pad0;
    int pad1;
} pc;

/* Set 0: Source cascade (read) */
layout(SET_BINDING(0, 0)) uniform sampler3D src_cascade;

/* Set 1: Destination cascade (write) */
layout(rgba16f, SET_BINDING(1, 0)) writeonly uniform image3D dst_cascade;

void main() {
    ivec3 dst_pos = ivec3(gl_GlobalInvocationID.xyz);

    if (dst_pos.x >= pc.dst_dims.x ||
        dst_pos.y >= pc.dst_dims.y ||
        dst_pos.z >= pc.dst_dims.z) {
        return;
    }

    /* Map destination texel to source region center */
    vec3 src_center = vec3(dst_pos * 2) + vec3(1.0);
    vec3 src_dims_f = vec3(pc.src_dims);

    /* Sample a 2x2x2 region for downsampling with minimal bleed.
       Tight sampling prevents light from bleeding through thin walls. */
    vec4 total_radiance = vec4(0.0);
    float total_weight = 0.0;

    for (int dz = 0; dz <= 1; dz++) {
        for (int dy = 0; dy <= 1; dy++) {
            for (int dx = 0; dx <= 1; dx++) {
                ivec3 src_pos = ivec3(src_center) + ivec3(dx, dy, dz);

                /* Bounds check */
                if (src_pos.x < 0 || src_pos.x >= pc.src_dims.x ||
                    src_pos.y < 0 || src_pos.y >= pc.src_dims.y ||
                    src_pos.z < 0 || src_pos.z >= pc.src_dims.z) {
                    continue;
                }

                /* Sample source cascade */
                vec3 uvw = (vec3(src_pos) + 0.5) / src_dims_f;
                vec4 sample_val = texture(src_cascade, uvw);

                /* Simple averaging - all 8 samples weighted equally */
                float weight = 1.0;

                total_radiance += sample_val * weight;
                total_weight += weight;
            }
        }
    }

    /* Average and apply aggressive energy conservation to limit bleeding */
    vec4 result = vec4(0.0);
    if (total_weight > 0.001) {
        result = total_radiance / total_weight;

        /* Cubic falloff to severely limit light travel distance.
           Without geometry-aware propagation, aggressive falloff prevents wall bleed. */
        float falloff = pc.falloff_factor * pc.falloff_factor * pc.falloff_factor;
        result.rgb *= falloff;

        /* Very aggressive energy conservation - GI should be subtle fill light only */
        result.rgb *= pc.energy_conserve * 0.25;

        /* Tight clamp - emissive contribution should stay local */
        result.rgb = min(result.rgb, vec3(0.8));
    }

    imageStore(dst_cascade, dst_pos, result);
}
