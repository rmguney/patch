#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(push_constant) uniform Constants {
    ivec3 src_dims;
    int src_level;
    ivec3 dst_dims;
    int dst_level;
    float falloff_factor;
    float energy_conserve;
    int pad0;
    int pad1;
} pc;

/* Set 0: Source cascade (read) */
layout(SET_BINDING(0, 0)) uniform sampler3D src_cascade;

/* Set 1: Destination cascade (write) */
layout(rgba16f, SET_BINDING(1, 0)) writeonly uniform image3D dst_cascade;

void main() {
    ivec3 dst_pos = ivec3(gl_GlobalInvocationID.xyz);

    if (dst_pos.x >= pc.dst_dims.x ||
        dst_pos.y >= pc.dst_dims.y ||
        dst_pos.z >= pc.dst_dims.z) {
        return;
    }

    /* Map destination texel to source region (2x2x2) */
    ivec3 src_base = dst_pos * 2;

    /* Accumulate radiance from 2x2x2 source region */
    vec4 total_radiance = vec4(0.0);
    float total_weight = 0.0;

    for (int dz = 0; dz < 2; dz++) {
        for (int dy = 0; dy < 2; dy++) {
            for (int dx = 0; dx < 2; dx++) {
                ivec3 src_pos = src_base + ivec3(dx, dy, dz);

                /* Bounds check */
                if (src_pos.x >= pc.src_dims.x ||
                    src_pos.y >= pc.src_dims.y ||
                    src_pos.z >= pc.src_dims.z) {
                    continue;
                }

                /* Sample source cascade */
                vec3 uvw = (vec3(src_pos) + 0.5) / vec3(pc.src_dims);
                vec4 sample_val = texture(src_cascade, uvw);

                /* Weight by radiance magnitude (brighter = more influence) */
                float luminance = dot(sample_val.rgb, vec3(0.2126, 0.7152, 0.0722));
                float weight = 1.0 + luminance * 0.5;

                total_radiance += sample_val * weight;
                total_weight += weight;
            }
        }
    }

    /* Average and apply energy conservation */
    vec4 result = vec4(0.0);
    if (total_weight > 0.001) {
        result = total_radiance / total_weight;

        /* Apply falloff for distance (coarser levels represent farther light) */
        result.rgb *= pc.falloff_factor;

        /* Energy conservation - prevent explosion */
        result.rgb *= pc.energy_conserve;

        /* Clamp to prevent HDR overflow */
        result.rgb = min(result.rgb, vec3(10.0));
    }

    imageStore(dst_cascade, dst_pos, result);
}
