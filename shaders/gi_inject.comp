#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int _pad0;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int reflection_quality;
} pc;

ivec3 pc_grid_size;
ivec3 pc_chunks_dim;
int pc_total_chunks;

/* Set 0: Voxel data + shadow volume + materials */
layout(std430, SET_BINDING(0, 0)) readonly buffer VoxelBuffer {
    uint voxel_data[];
};

layout(std430, SET_BINDING(0, 1)) readonly buffer ChunkHeaders {
    uvec4 chunk_headers[];
};

layout(SET_BINDING(0, 2)) uniform usampler3D shadow_volume_tex;

layout(std140, SET_BINDING(0, 3)) uniform MaterialPalette {
    vec4 materials[512];
};

#include "include/materials.glsl"
#include "include/data_terrain.glsl"

/* Set 1: Cascade output (level 0) */
layout(rgba16f, SET_BINDING(1, 0)) writeonly uniform image3D out_cascade;

const vec3 KEY_LIGHT_DIR = normalize(vec3(-0.6, 0.9, 0.35));
const vec3 KEY_LIGHT_COLOR = vec3(1.0, 0.98, 0.95);
const float KEY_LIGHT_STRENGTH = 1.5;

const int MAX_SHADOW_STEPS = 64;

bool sample_shadow_volume(ivec3 voxel_pos) {
    ivec3 shadow_pos = voxel_pos >> 1;
    ivec3 shadow_size = textureSize(shadow_volume_tex, 0);

    if (shadow_pos.x < 0 || shadow_pos.x >= shadow_size.x ||
        shadow_pos.y < 0 || shadow_pos.y >= shadow_size.y ||
        shadow_pos.z < 0 || shadow_pos.z >= shadow_size.z) {
        return false;
    }

    uint packed = texelFetch(shadow_volume_tex, shadow_pos, 0).r;
    int bit_idx = (voxel_pos.x & 1) + ((voxel_pos.y & 1) << 1) + ((voxel_pos.z & 1) << 2);
    return (packed & (1u << bit_idx)) != 0u;
}

bool sample_shadow_mip1(ivec3 voxel_pos) {
    ivec3 mip1_pos = voxel_pos >> 2;
    ivec3 mip1_size = textureSize(shadow_volume_tex, 1);

    if (mip1_pos.x < 0 || mip1_pos.x >= mip1_size.x ||
        mip1_pos.y < 0 || mip1_pos.y >= mip1_size.y ||
        mip1_pos.z < 0 || mip1_pos.z >= mip1_size.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip1_pos, 1).r != 0u;
}

/* Trace shadow ray from voxel toward light, returns 1.0 if lit, 0.0 if shadowed */
float trace_shadow_to_light(vec3 world_pos) {
    vec3 rd = KEY_LIGHT_DIR;
    vec3 ro = world_pos + rd * pc.voxel_size * 0.5;

    vec3 grid_pos = (ro - pc.bounds_min) / pc.voxel_size;
    ivec3 map_pos = ivec3(floor(grid_pos));
    vec3 delta = abs(1.0 / rd);
    ivec3 step_dir = ivec3(sign(rd));
    vec3 side = (sign(rd) * (vec3(map_pos) - grid_pos) + sign(rd) * 0.5 + 0.5) * delta;

    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {
        if (map_pos.x < 0 || map_pos.x >= pc_grid_size.x ||
            map_pos.y < 0 || map_pos.y >= pc_grid_size.y ||
            map_pos.z < 0 || map_pos.z >= pc_grid_size.z) {
            return 1.0;
        }

        if (!sample_shadow_mip1(map_pos)) {
            ivec3 mip1_pos = map_pos >> 2;
            ivec3 next_boundary = (mip1_pos + max(step_dir, ivec3(0))) << 2;
            vec3 t_to_boundary = (vec3(next_boundary) - grid_pos) / rd;
            float t_skip = max(max(t_to_boundary.x, t_to_boundary.y), t_to_boundary.z);
            grid_pos += rd * max(t_skip, 1.0);
            map_pos = ivec3(floor(grid_pos));
            side = (sign(rd) * (vec3(map_pos) - grid_pos) + sign(rd) * 0.5 + 0.5) * delta;
            continue;
        }

        if (sample_shadow_volume(map_pos)) {
            return 0.0;
        }

        if (side.x < side.y) {
            if (side.x < side.z) {
                map_pos.x += step_dir.x;
                side.x += delta.x;
            } else {
                map_pos.z += step_dir.z;
                side.z += delta.z;
            }
        } else {
            if (side.y < side.z) {
                map_pos.y += step_dir.y;
                side.y += delta.y;
            } else {
                map_pos.z += step_dir.z;
                side.z += delta.z;
            }
        }
    }

    return 1.0;
}

/* Find surface normal by checking neighboring voxels */
vec3 estimate_surface_normal(ivec3 voxel_pos) {
    vec3 normal = vec3(0.0);

    if (sample_material(voxel_pos + ivec3(1, 0, 0)) == 0u) normal.x += 1.0;
    if (sample_material(voxel_pos + ivec3(-1, 0, 0)) == 0u) normal.x -= 1.0;
    if (sample_material(voxel_pos + ivec3(0, 1, 0)) == 0u) normal.y += 1.0;
    if (sample_material(voxel_pos + ivec3(0, -1, 0)) == 0u) normal.y -= 1.0;
    if (sample_material(voxel_pos + ivec3(0, 0, 1)) == 0u) normal.z += 1.0;
    if (sample_material(voxel_pos + ivec3(0, 0, -1)) == 0u) normal.z -= 1.0;

    float len = length(normal);
    if (len < 0.001) {
        return vec3(0.0, 1.0, 0.0);
    }
    return normal / len;
}

void main() {
    ivec3 cascade_pos = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 cascade_size = imageSize(out_cascade);

    if (cascade_pos.x >= cascade_size.x ||
        cascade_pos.y >= cascade_size.y ||
        cascade_pos.z >= cascade_size.z) {
        return;
    }

    pc_grid_size = pc.grid_size;
    pc_chunks_dim = pc.chunks_dim;
    pc_total_chunks = pc.total_chunks;

    /* Map cascade position to voxel grid position
       Cascade level 0 has 1:1 correspondence with voxel grid (scaled) */
    vec3 bounds_size = pc.bounds_max - pc.bounds_min;
    vec3 cascade_uvw = (vec3(cascade_pos) + 0.5) / vec3(cascade_size);
    vec3 world_pos = pc.bounds_min + cascade_uvw * bounds_size;
    ivec3 voxel_pos = ivec3(floor((world_pos - pc.bounds_min) / pc.voxel_size));

    /* Check if this voxel is solid */
    uint mat = sample_material(voxel_pos);
    if (mat == 0u) {
        imageStore(out_cascade, cascade_pos, vec4(0.0));
        return;
    }

    /* Get material properties */
    vec3 albedo = get_material_color(mat);
    float emissive = get_material_emissive(mat);

    /* Start with emissive contribution (boosted for visible color bleeding) */
    vec3 radiance = albedo * emissive * 3.0;

    /* Estimate surface normal */
    vec3 N = estimate_surface_normal(voxel_pos);

    /* Add ambient contribution so ALL surfaces bleed some color (not just sun-lit) */
    vec3 ambient_color = vec3(0.5, 0.6, 0.8); /* Sky-ish ambient */
    float ambient_strength = 0.3;
    radiance += albedo * ambient_color * ambient_strength;

    /* Check if surface faces the light */
    float NdotL = dot(N, KEY_LIGHT_DIR);
    if (NdotL > 0.0) {
        /* Trace shadow ray */
        float shadow = trace_shadow_to_light(world_pos);

        /* Add direct lighting contribution */
        radiance += albedo * KEY_LIGHT_COLOR * KEY_LIGHT_STRENGTH * NdotL * shadow;
    }

    /* Encode radiance with dominant direction (packed in alpha as hemisphere index) */
    float dir_encode = 0.0;
    if (length(radiance) > 0.001) {
        dir_encode = (N.y + 1.0) * 0.5;
    }

    imageStore(out_cascade, cascade_pos, vec4(radiance, dir_encode));
}
