#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

/* Push constants */
layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int _pad0;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int taa_quality;
} pc;

#include "include/gbuffer_sample.glsl"

/* Global parameters required by data_terrain.glsl */
ivec3 pc_grid_size;
ivec3 pc_chunks_dim;
int pc_total_chunks;

/* Terrain data for HDDA (set 0) */
layout(std430, SET_BINDING(0, 0)) readonly buffer VoxelBuffer {
    uint voxel_data[];
};

layout(std430, SET_BINDING(0, 1)) readonly buffer ChunkHeaders {
    uvec4 chunk_headers[];
};

/* Shadow volume texture (set 0, binding 2) - R8_UINT with 3 mip levels */
layout(SET_BINDING(0, 2)) uniform usampler3D shadow_volume_tex;

#include "include/data_terrain.glsl"

/* G-buffer inputs (set 1) */
layout(SET_BINDING(1, 0)) uniform sampler2D gbuffer_depth;
layout(SET_BINDING(1, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(1, 2)) uniform sampler2D gbuffer_world_pos;
layout(SET_BINDING(1, 3)) uniform sampler2D blue_noise_tex;

/* Shadow output (set 2) */
layout(r8, SET_BINDING(2, 0)) writeonly uniform image2D out_shadow;

/* Constants (CHUNK_SIZE, REGION_SIZE, CHUNK_UINT_COUNT from hdda_types.glsl) */
const int BASE_SHADOW_STEPS = 128;  /* Base step count for far surfaces */
const float SHADOW_MAX_DIST = 50.0;

/* Sun direction */
const vec3 SUN_DIR = normalize(vec3(-0.6, 0.9, 0.35));

vec3 world_to_grid(vec3 world_pos) {
    return (world_pos - pc.bounds_min) / pc.voxel_size;
}

/* Shadow volume dimensions computed from grid_size (avoids per-sample textureSize calls) */
ivec3 shadow_dim0;  /* mip0: half-res */
ivec3 shadow_dim1;  /* mip1: quarter-res */
ivec3 shadow_dim2;  /* mip2: eighth-res */

/* Sample shadow volume occupancy at voxel position
   Shadow volume is half-resolution: 2x2x2 voxels packed per texel
   Returns true if occupied */
bool sample_shadow_volume(ivec3 voxel_pos) {
    /* Shadow volume texel coords (half res) */
    ivec3 shadow_pos = voxel_pos >> 1;

    if (shadow_pos.x < 0 || shadow_pos.x >= shadow_dim0.x ||
        shadow_pos.y < 0 || shadow_pos.y >= shadow_dim0.y ||
        shadow_pos.z < 0 || shadow_pos.z >= shadow_dim0.z) {
        return false;
    }

    /* Fetch packed occupancy byte */
    uint packed = texelFetch(shadow_volume_tex, shadow_pos, 0).r;

    /* Compute bit index within 2x2x2 */
    int bit_idx = (voxel_pos.x & 1) + ((voxel_pos.y & 1) << 1) + ((voxel_pos.z & 1) << 2);

    return (packed & (1u << bit_idx)) != 0u;
}

/* Sample shadow volume mip1 (4x4x4 voxels per texel) */
bool sample_shadow_mip1(ivec3 voxel_pos) {
    ivec3 mip1_pos = voxel_pos >> 2;  /* Divide by 4 */

    if (mip1_pos.x < 0 || mip1_pos.x >= shadow_dim1.x ||
        mip1_pos.y < 0 || mip1_pos.y >= shadow_dim1.y ||
        mip1_pos.z < 0 || mip1_pos.z >= shadow_dim1.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip1_pos, 1).r != 0u;
}

/* Sample shadow volume mip2 (8x8x8 voxels per texel) */
bool sample_shadow_mip2(ivec3 voxel_pos) {
    ivec3 mip2_pos = voxel_pos >> 3;  /* Divide by 8 */

    if (mip2_pos.x < 0 || mip2_pos.x >= shadow_dim2.x ||
        mip2_pos.y < 0 || mip2_pos.y >= shadow_dim2.y ||
        mip2_pos.z < 0 || mip2_pos.z >= shadow_dim2.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip2_pos, 2).r != 0u;
}

/* Trace shadow ray, returns hit distance (max_dist if no hit) */
float trace_shadow_hdda_dist(vec3 origin, vec3 rd, float max_dist, int max_steps) {
    vec2 box_hit = hdda_intersect_aabb(origin, rd, pc.bounds_min, pc.bounds_max);
    if (box_hit.x > box_hit.y || box_hit.y < 0.0) {
        return max_dist;
    }

    float t_start = max(box_hit.x, 0.001);
    float t_end = min(box_hit.y, max_dist);

    if (t_start >= t_end) {
        return max_dist;
    }

    vec3 start_pos = origin + rd * t_start;
    vec3 grid_pos = world_to_grid(start_pos);
    grid_pos = clamp(grid_pos, vec3(0.0), vec3(pc.grid_size) - 0.001);

    ivec3 map_pos = ivec3(floor(grid_pos));
    vec3 delta_dist = abs(1.0 / rd);
    ivec3 step_dir = ivec3(sign(rd));
    vec3 side_dist = (sign(rd) * (vec3(map_pos) - grid_pos) + sign(rd) * 0.5 + 0.5) * delta_dist;

    ivec3 last_mip2_pos = ivec3(-1000);
    ivec3 last_mip1_pos = ivec3(-1000);
    bool mip2_empty = false;
    bool mip1_empty = false;

    for (int i = 0; i < max_steps; i++) {
        if (map_pos.x < 0 || map_pos.x >= pc.grid_size.x ||
            map_pos.y < 0 || map_pos.y >= pc.grid_size.y ||
            map_pos.z < 0 || map_pos.z >= pc.grid_size.z) {
            return max_dist;
        }

        /* Level 2: mip2 occupancy (8x8x8 voxels) */
        ivec3 current_mip2 = map_pos >> 3;
        if (current_mip2 != last_mip2_pos) {
            last_mip2_pos = current_mip2;
            mip2_empty = !sample_shadow_mip2(map_pos);
            last_mip1_pos = ivec3(-1000);
        }

        if (mip2_empty) {
            /* Skip to mip2 boundary (8x8x8 voxels) instead of stepping one voxel */
            ivec3 mip2_min = current_mip2 << 3;
            ivec3 mip2_max = mip2_min + 7;
            ivec3 exit_pos = mix(mip2_min - 1, mip2_max + 1, greaterThan(step_dir, ivec3(0)));
            vec3 steps_to_exit = vec3(exit_pos - map_pos) / vec3(step_dir);
            steps_to_exit = max(steps_to_exit, vec3(1.0));
            int skip = int(min(min(steps_to_exit.x, steps_to_exit.y), steps_to_exit.z));
            map_pos += step_dir * skip;
            side_dist += vec3(skip) * delta_dist;
            i += skip - 1;
            continue;
        }

        /* Level 1: mip1 occupancy (4x4x4 voxels) */
        ivec3 current_mip1 = map_pos >> 2;
        if (current_mip1 != last_mip1_pos) {
            last_mip1_pos = current_mip1;
            mip1_empty = !sample_shadow_mip1(map_pos);
        }

        if (mip1_empty) {
            /* Skip to mip1 boundary (4x4x4 voxels) instead of stepping one voxel */
            ivec3 mip1_min = current_mip1 << 2;
            ivec3 mip1_max = mip1_min + 3;
            ivec3 exit_pos = mix(mip1_min - 1, mip1_max + 1, greaterThan(step_dir, ivec3(0)));
            vec3 steps_to_exit = vec3(exit_pos - map_pos) / vec3(step_dir);
            steps_to_exit = max(steps_to_exit, vec3(1.0));
            int skip = int(min(min(steps_to_exit.x, steps_to_exit.y), steps_to_exit.z));
            map_pos += step_dir * skip;
            side_dist += vec3(skip) * delta_dist;
            i += skip - 1;
            continue;
        }

        /* Level 0: Per-voxel check against shadow volume */
        if (sample_shadow_volume(map_pos)) {
            /* Compute actual world distance to hit voxel center */
            vec3 hit_grid = vec3(map_pos) + 0.5;
            vec3 hit_world = pc.bounds_min + hit_grid * pc.voxel_size;
            return length(hit_world - origin);
        }

        bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
        side_dist += vec3(mask) * delta_dist;
        map_pos += ivec3(mask) * step_dir;
    }

    return max_dist;
}

/* Original interface for compatibility */
float trace_shadow_hdda(vec3 origin, vec3 rd, float max_dist, int max_steps) {
    return trace_shadow_hdda_dist(origin, rd, max_dist, max_steps) < max_dist ? 0.0 : 1.0;
}

void main() {
    /* Initialize globals for data_terrain.glsl */
    pc_grid_size = pc.grid_size;
    pc_chunks_dim = pc.chunks_dim;
    pc_total_chunks = pc.total_chunks;

    /* Cache shadow volume dimensions (computed from grid_size, avoids textureSize calls) */
    shadow_dim0 = (pc.grid_size + 1) >> 1;  /* mip0: half-res */
    shadow_dim1 = (pc.grid_size + 3) >> 2;  /* mip1: quarter-res */
    shadow_dim2 = (pc.grid_size + 7) >> 3;  /* mip2: eighth-res */

    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(out_shadow);

    if (pixel.x >= screen_size.x || pixel.y >= screen_size.y) {
        return;
    }

    GBufferSample g = sample_gbuffer_shadow(
        pixel,
        gbuffer_depth, gbuffer_normal, gbuffer_world_pos
    );

    if (g.is_sky) {
        imageStore(out_shadow, pixel, vec4(1.0));
        return;
    }

    vec3 normal = normalize(g.normal);

    /* Distance-based step reduction for FAR surfaces only.
       Close surfaces keep full steps for shadow accuracy.
       Far surfaces can use fewer steps - artifacts less visible at distance. */
    float surface_dist = length(g.world_pos - pc.camera_pos);
    int shadow_steps = BASE_SHADOW_STEPS;
    if (surface_dist > 100.0) {
        shadow_steps = 64;   /* Very far: half steps */
    } else if (surface_dist > 60.0) {
        shadow_steps = 96;   /* Far: 75% steps */
    }
    /* Close/mid (<60m): keep full 128 steps */

    float shadow = 1.0;

    if (pc.shadow_quality > 0) {
        vec2 noise_uv = vec2(pixel) / 128.0;
        float spatial_noise = texture(blue_noise_tex, noise_uv).r;
        float temporal_noise = fract(spatial_noise + float(pc.frame_count) * 0.6180339887);

        vec3 tangent = normalize(cross(SUN_DIR, vec3(0.0, 1.0, 0.01)));
        vec3 bitangent = cross(SUN_DIR, tangent);

        /* Bias along light direction instead of normal - ensures shadow ray starts
           outside occluders regardless of surface orientation */
        float light_bias = pc.voxel_size * 1.0;
        /* Angle-dependent normal bias: steeper angles need less bias */
        float angle_factor = max(0.2, dot(-SUN_DIR, normal));
        float normal_bias = pc.voxel_size * 0.3 / angle_factor;
        vec3 shadow_origin = g.world_pos + SUN_DIR * light_bias + normal * normal_bias;

        /* Sample count: quality-based with reduction for far surfaces */
        int base_samples = 3 + pc.shadow_quality;
        int num_samples = base_samples;
        if (surface_dist > 80.0) {
            num_samples = max(2, base_samples - 2);  /* Far: fewer samples */
        } else if (surface_dist > 40.0) {
            num_samples = max(3, base_samples - 1);  /* Mid: slight reduction */
        }
        float shadow_sum = 0.0;

        /* Contact hardening only when enabled, otherwise use constant penumbra */
        float base_penumbra = 0.04 + 0.02 * float(pc.shadow_quality);
        float penumbra = base_penumbra;

        if (pc.shadow_contact != 0 && pc.shadow_quality >= 2) {
            /* Contact hardening: trace center ray to find occluder distance */
            float occluder_dist = trace_shadow_hdda_dist(shadow_origin, SUN_DIR, SHADOW_MAX_DIST, shadow_steps);

            /* Scale penumbra: near occluder = sharper, far = softer
               If center ray misses, use full penumbra (jittered rays may still hit) */
            if (occluder_dist < SHADOW_MAX_DIST) {
                float contact_factor = smoothstep(0.0, 8.0, occluder_dist) * 0.7 + 0.3;
                penumbra = base_penumbra * contact_factor;
            }
        }

        for (int s = 0; s < num_samples; s++) {
            /* Per-sample temporal variation breaks up patterns across frames */
            float sample_temporal = fract(temporal_noise + float(s) * 0.1618033989);

            /* Golden angle + per-sample temporal offset for angular distribution */
            float golden_angle = 2.399963229; /* 137.5 degrees in radians */
            float angle = float(s) * golden_angle + sample_temporal * 6.28318;

            /* Stratified radius with temporal jitter for better frame-to-frame coverage */
            float radius_base = sqrt((float(s) + sample_temporal) / float(num_samples));
            float radius = radius_base * penumbra;

            vec3 jitter = tangent * cos(angle) * radius + bitangent * sin(angle) * radius;
            vec3 jittered_light = normalize(SUN_DIR + jitter);

            shadow_sum += trace_shadow_hdda(shadow_origin, jittered_light, SHADOW_MAX_DIST, shadow_steps);
        }

        shadow = shadow_sum / float(num_samples);
        /* Remap shadow: 0.05 minimum prevents pure black while maintaining contrast */
        shadow = mix(0.05, 1.0, shadow);
    }

    imageStore(out_shadow, pixel, vec4(shadow, 0.0, 0.0, 0.0));
}
