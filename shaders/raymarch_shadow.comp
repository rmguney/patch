#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

/* Push constants */
layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    float pad1;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int rt_quality;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int reserved[6];
} pc;

/* Terrain data for HDDA (set 0) */
layout(std430, SET_BINDING(0, 0)) readonly buffer VoxelBuffer {
    uint voxel_data[];
};

layout(std430, SET_BINDING(0, 1)) readonly buffer ChunkHeaders {
    uvec4 chunk_headers[];
};

/* G-buffer inputs (set 1) */
layout(SET_BINDING(1, 0)) uniform sampler2D gbuffer_depth;
layout(SET_BINDING(1, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(1, 2)) uniform sampler2D blue_noise_tex;

/* Shadow output (set 2) */
layout(r8, SET_BINDING(2, 0)) writeonly uniform image2D out_shadow;

/* Constants */
const int CHUNK_SIZE = 32;
const int REGION_SIZE = 8;
const int CHUNK_UINT_COUNT = 8192;
const int MAX_SHADOW_STEPS = 256;
const float SHADOW_MAX_DIST = 50.0;

/* Sun direction */
const vec3 SUN_DIR = normalize(vec3(-0.6, 0.9, 0.35));

vec2 intersect_aabb(vec3 ro, vec3 rd, vec3 box_min, vec3 box_max) {
    vec3 inv_rd = 1.0 / rd;
    vec3 t0 = (box_min - ro) * inv_rd;
    vec3 t1 = (box_max - ro) * inv_rd;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float enter = max(max(tmin.x, tmin.y), tmin.z);
    float exit = min(min(tmax.x, tmax.y), tmax.z);
    return vec2(enter, exit);
}

vec3 world_to_grid(vec3 world_pos) {
    return (world_pos - pc.bounds_min) / pc.voxel_size;
}

/* Level 2: Check if chunk has any solid voxels */
bool chunk_has_any(int chunk_idx) {
    if (chunk_idx < 0 || chunk_idx >= pc.total_chunks) return false;
    return (chunk_headers[chunk_idx].z & 0xFFu) != 0u;
}

/* Level 1: Check 8x8x8 region occupancy */
bool region_occupied(int chunk_idx, ivec3 region) {
    uvec2 level0 = chunk_headers[chunk_idx].xy;
    int bit = region.x + region.y * 4 + region.z * 16;
    if (bit < 32) {
        return (level0.x & (1u << bit)) != 0u;
    } else {
        return (level0.y & (1u << (bit - 32))) != 0u;
    }
}

/* Level 0: Sample voxel material */
uint get_material(ivec3 p) {
    if (p.x < 0 || p.x >= pc.grid_size.x ||
        p.y < 0 || p.y >= pc.grid_size.y ||
        p.z < 0 || p.z >= pc.grid_size.z) {
        return 0u;
    }

    ivec3 chunk_pos = p / CHUNK_SIZE;
    int chunk_idx = chunk_pos.x + chunk_pos.y * pc.chunks_dim.x +
                    chunk_pos.z * pc.chunks_dim.x * pc.chunks_dim.y;

    ivec3 local = p - chunk_pos * CHUNK_SIZE;
    int local_idx = local.x + local.y * CHUNK_SIZE + local.z * CHUNK_SIZE * CHUNK_SIZE;

    int chunk_data_offset = chunk_idx * CHUNK_UINT_COUNT;
    int uint_idx = local_idx / 4;
    int byte_idx = local_idx % 4;

    uint packed = voxel_data[chunk_data_offset + uint_idx];
    return (packed >> (byte_idx * 8)) & 0xFFu;
}

vec3 reconstruct_world_pos(vec2 uv, float depth) {
    vec2 ndc = uv * 2.0 - 1.0;

    if (pc.is_orthographic != 0) {
        vec4 near_clip = vec4(ndc.x, ndc.y, 0.0, 1.0);
        vec4 far_clip = vec4(ndc.x, ndc.y, 1.0, 1.0);
        vec4 near_view = pc.inv_projection * near_clip;
        vec4 far_view = pc.inv_projection * far_clip;
        vec3 near_world = (pc.inv_view * vec4(near_view.xyz, 1.0)).xyz;
        vec3 far_world = (pc.inv_view * vec4(far_view.xyz, 1.0)).xyz;
        vec3 ray_dir = normalize(far_world - near_world);
        return near_world + ray_dir * depth;
    } else {
        vec4 ray_clip = vec4(ndc.x, ndc.y, -1.0, 1.0);
        vec4 ray_view = pc.inv_projection * ray_clip;
        ray_view.z = -1.0;
        ray_view.w = 0.0;
        vec3 ray_world = normalize((pc.inv_view * ray_view).xyz);
        return pc.camera_pos + ray_world * depth;
    }
}

float trace_shadow_hdda(vec3 origin, vec3 rd, float max_dist) {
    vec2 box_hit = intersect_aabb(origin, rd, pc.bounds_min, pc.bounds_max);
    if (box_hit.x > box_hit.y || box_hit.y < 0.0) {
        return 1.0;
    }

    float t_start = max(box_hit.x, 0.001);
    float t_end = min(box_hit.y, max_dist);

    if (t_start >= t_end) {
        return 1.0;
    }

    vec3 start_pos = origin + rd * t_start;
    vec3 grid_pos = world_to_grid(start_pos);
    grid_pos = clamp(grid_pos, vec3(0.0), vec3(pc.grid_size) - 0.001);

    ivec3 map_pos = ivec3(floor(grid_pos));
    vec3 delta_dist = abs(1.0 / rd);
    ivec3 step_dir = ivec3(sign(rd));
    vec3 side_dist = (sign(rd) * (vec3(map_pos) - grid_pos) + sign(rd) * 0.5 + 0.5) * delta_dist;

    ivec3 last_chunk = ivec3(-1000);
    ivec3 last_region = ivec3(-1000);
    bool chunk_empty = false;
    bool region_empty = false;
    int current_chunk_idx = -1;

    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {
        if (map_pos.x < 0 || map_pos.x >= pc.grid_size.x ||
            map_pos.y < 0 || map_pos.y >= pc.grid_size.y ||
            map_pos.z < 0 || map_pos.z >= pc.grid_size.z) {
            return 1.0;
        }

        /* Level 2: Chunk occupancy */
        ivec3 current_chunk = map_pos / CHUNK_SIZE;
        if (current_chunk != last_chunk) {
            last_chunk = current_chunk;
            current_chunk_idx = current_chunk.x + current_chunk.y * pc.chunks_dim.x +
                               current_chunk.z * pc.chunks_dim.x * pc.chunks_dim.y;
            chunk_empty = !chunk_has_any(current_chunk_idx);
            last_region = ivec3(-1000);
        }

        if (chunk_empty) {
            bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
            side_dist += vec3(mask) * delta_dist;
            map_pos += ivec3(mask) * step_dir;
            continue;
        }

        /* Level 1: Region occupancy (8x8x8) */
        ivec3 local_pos = map_pos - current_chunk * CHUNK_SIZE;
        ivec3 current_region = local_pos / REGION_SIZE;
        if (current_region != last_region) {
            last_region = current_region;
            region_empty = !region_occupied(current_chunk_idx, current_region);
        }

        if (region_empty) {
            bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
            side_dist += vec3(mask) * delta_dist;
            map_pos += ivec3(mask) * step_dir;
            continue;
        }

        /* Level 0: Per-voxel check */
        uint mat = get_material(map_pos);
        if (mat != 0u) {
            return 0.0;
        }

        bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
        side_dist += vec3(mask) * delta_dist;
        map_pos += ivec3(mask) * step_dir;
    }

    return 1.0;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(out_shadow);

    if (pixel.x >= screen_size.x || pixel.y >= screen_size.y) {
        return;
    }

    vec2 uv = (vec2(pixel) + 0.5) / vec2(screen_size);

    float linear_depth = texelFetch(gbuffer_depth, pixel, 0).r;

    if (linear_depth > 1e9) {
        imageStore(out_shadow, pixel, vec4(1.0));
        return;
    }

    vec3 world_pos = reconstruct_world_pos(uv, linear_depth);
    vec3 normal = texelFetch(gbuffer_normal, pixel, 0).rgb * 2.0 - 1.0;
    normal = normalize(normal);

    float shadow = 1.0;

    if (pc.rt_quality > 0) {
        vec2 noise_uv = vec2(pixel) / 128.0;
        float base_noise = texture(blue_noise_tex, noise_uv).r;
        base_noise = fract(base_noise + float(pc.frame_count) * 0.6180339887);

        float origin_jitter = (base_noise - 0.5) * pc.voxel_size * 0.5;
        vec3 shadow_origin = world_pos + normal * (pc.voxel_size * 0.5 + origin_jitter);

        vec3 tangent = normalize(cross(SUN_DIR, vec3(0.0, 1.0, 0.01)));
        vec3 bitangent = cross(SUN_DIR, tangent);

        /* Scale samples: quality 1=4, 2=8, 3=12 samples for smoother soft shadows */
        int num_samples = pc.rt_quality * 4;
        float shadow_sum = 0.0;
        float penumbra = 0.03 + 0.015 * float(pc.rt_quality);

        for (int s = 0; s < num_samples; s++) {
            float noise = fract(base_noise + float(s) * 0.618);
            float angle = (float(s) + noise) * 6.28318 / float(num_samples);
            float radius = sqrt((float(s) + noise) / float(num_samples)) * penumbra;
            vec3 jitter = tangent * cos(angle) * radius + bitangent * sin(angle) * radius;
            vec3 jittered_light = normalize(SUN_DIR + jitter);

            shadow_sum += trace_shadow_hdda(shadow_origin, jittered_light, SHADOW_MAX_DIST);
        }

        shadow = shadow_sum / float(num_samples);
        shadow = mix(0.3, 1.0, shadow);
    }

    imageStore(out_shadow, pixel, vec4(shadow, 0.0, 0.0, 0.0));
}
