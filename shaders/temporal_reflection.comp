#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int _pad0;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int reflection_quality;
} pc;

/* Set 0: inputs */
layout(SET_BINDING(0, 0)) uniform sampler2D gbuffer_linear_depth;
layout(SET_BINDING(0, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(0, 2)) uniform sampler2D gbuffer_motion_vector;
layout(SET_BINDING(0, 3)) uniform sampler2D gbuffer_material;
layout(SET_BINDING(0, 4)) uniform sampler2D reflection_current;
layout(SET_BINDING(0, 5)) uniform sampler2D reflection_history;

/* Set 1: output */
layout(rgba8, SET_BINDING(1, 0)) writeonly uniform image2D out_reflection_resolved;

const float HISTORY_BLEND_MAX = 0.8;   /* Longer hold for stable reflections */
const float HISTORY_BLEND_MIN = 0.05;  /* Nearly instant during motion */
const float DEPTH_REJECT_THRESHOLD = 0.08;
const float NORMAL_REJECT_THRESHOLD = 0.8;
const float TEMPORAL_UV_MARGIN = 0.06;
const float HISTORY_HOLD_BLEND = 0.93;
const float HOLD_ALPHA_EPS = 0.01;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(out_reflection_resolved);
    if (pixel.x >= size.x || pixel.y >= size.y)
        return;

    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(size);

    vec4 current_reflection = texelFetch(reflection_current, pixel, 0);

    if (pc.history_valid == 0) {
        imageStore(out_reflection_resolved, pixel, current_reflection);
        return;
    }

    vec2 motion = texture(gbuffer_motion_vector, uv).xy;
    vec2 prev_uv = uv + motion;

    if (prev_uv.x < -TEMPORAL_UV_MARGIN || prev_uv.x > 1.0 + TEMPORAL_UV_MARGIN ||
        prev_uv.y < -TEMPORAL_UV_MARGIN || prev_uv.y > 1.0 + TEMPORAL_UV_MARGIN) {
        imageStore(out_reflection_resolved, pixel, current_reflection);
        return;
    }

    vec2 prev_uv_clamped = clamp(prev_uv, vec2(0.0), vec2(1.0));
    float edge_dx = max(abs(prev_uv.x - prev_uv_clamped.x), abs(prev_uv.y - prev_uv_clamped.y));
    float edge_fade = 1.0 - clamp(edge_dx / TEMPORAL_UV_MARGIN, 0.0, 1.0);

    float current_depth = texelFetch(gbuffer_linear_depth, pixel, 0).r;
    float reproj_depth = texture(gbuffer_linear_depth, prev_uv_clamped).r;
    float depth_diff = abs(current_depth - reproj_depth) / max(current_depth, 0.001);
    bool depth_ok = depth_diff <= DEPTH_REJECT_THRESHOLD;

    vec3 current_normal = texelFetch(gbuffer_normal, pixel, 0).xyz * 2.0 - 1.0;
    vec3 reproj_normal = texture(gbuffer_normal, prev_uv_clamped).xyz * 2.0 - 1.0;
    bool normal_ok = dot(current_normal, reproj_normal) >= NORMAL_REJECT_THRESHOLD;

    /* Get roughness for roughness-aware blending */
    float roughness = texelFetch(gbuffer_material, pixel, 0).r;

    /* Roughness-aware history blend: rough surfaces use less history to avoid ghosting */
    float roughness_factor = 1.0 - roughness * roughness * 0.5;

    /* Sample motion from neighborhood to detect camera rotation (surfaces may not move but view changes) */
    float max_motion = length(motion);
    vec2 offsets[4] = vec2[4](vec2(-0.1, 0.0), vec2(0.1, 0.0), vec2(0.0, -0.1), vec2(0.0, 0.1));
    for (int i = 0; i < 4; i++) {
        vec2 sample_uv = clamp(uv + offsets[i], vec2(0.0), vec2(1.0));
        max_motion = max(max_motion, length(texture(gbuffer_motion_vector, sample_uv).xy));
    }

    vec4 history_reflection = texture(reflection_history, prev_uv_clamped);

    float hold_factor = smoothstep(0.0, HOLD_ALPHA_EPS, history_reflection.a - current_reflection.a);
    if ((!depth_ok || !normal_ok) && hold_factor < 0.5) {
        imageStore(out_reflection_resolved, pixel, current_reflection);
        return;
    }

    float motion_len = max_motion * length(vec2(size));
    float velocity_weight = clamp(motion_len / 0.5, 0.0, 1.0);  /* Very sensitive */
    float history_blend = mix(HISTORY_BLEND_MAX * roughness_factor, HISTORY_BLEND_MIN, velocity_weight);
    history_blend = mix(history_blend, HISTORY_HOLD_BLEND, hold_factor);
    history_blend *= edge_fade;

    /* Blend RGB and alpha separately */
    vec3 resolved_color = mix(current_reflection.rgb, history_reflection.rgb, history_blend);
    float resolved_alpha = mix(current_reflection.a, history_reflection.a, history_blend);

    imageStore(out_reflection_resolved, pixel, vec4(resolved_color, resolved_alpha));
}
