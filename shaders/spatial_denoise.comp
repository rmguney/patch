#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int _pad0;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int reflection_quality;
} pc;

layout(SET_BINDING(0, 0)) uniform sampler2D gbuffer_linear_depth;
layout(SET_BINDING(0, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(0, 2)) uniform sampler2D lit_color_input;

layout(rgba8, SET_BINDING(1, 0)) writeonly uniform image2D out_denoised;

const float GOLDEN_ANGLE = 2.399963229728653;
const int SAMPLE_COUNT = 12;
const float SAMPLE_RADIUS = 3.0;
const float DEPTH_THRESHOLD = 0.05;

vec2 get_poisson_sample(int i, float rotation) {
    float r = sqrt(float(i + 1) / float(SAMPLE_COUNT + 1));
    float theta = float(i) * GOLDEN_ANGLE + rotation;
    return vec2(cos(theta), sin(theta)) * r * SAMPLE_RADIUS;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(out_denoised);
    if (pixel.x >= size.x || pixel.y >= size.y)
        return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);

    float depth_center = texture(gbuffer_linear_depth, uv).r;
    vec3 normal_center = texture(gbuffer_normal, uv).rgb * 2.0 - 1.0;
    vec4 color_center = texture(lit_color_input, uv);

    /* Sky pixels (depth=1.0) pass through unchanged */
    if (depth_center >= 0.9999) {
        imageStore(out_denoised, pixel, color_center);
        return;
    }

    /* Golden angle rotation per-pixel for temporal variance */
    float rotation = float(pc.frame_count) * GOLDEN_ANGLE + float(pixel.x * 73 + pixel.y * 137);

    vec3 color_sum = color_center.rgb;
    float weight_sum = 1.0;

    vec2 texel_size = 1.0 / vec2(size);

    for (int i = 0; i < SAMPLE_COUNT; i++) {
        vec2 offset = get_poisson_sample(i, rotation);
        vec2 sample_uv = uv + offset * texel_size;

        /* Clamp to valid range */
        sample_uv = clamp(sample_uv, vec2(0.0), vec2(1.0));

        float depth_sample = texture(gbuffer_linear_depth, sample_uv).r;
        vec3 normal_sample = texture(gbuffer_normal, sample_uv).rgb * 2.0 - 1.0;
        vec3 color_sample = texture(lit_color_input, sample_uv).rgb;

        /* Bilateral weights */
        float depth_diff = abs(depth_sample - depth_center);
        float depth_weight = exp(-depth_diff / DEPTH_THRESHOLD);

        float normal_dot = max(0.0, dot(normal_sample, normal_center));
        float normal_weight = step(0.9, normal_dot);

        float weight = depth_weight * normal_weight;

        color_sum += color_sample * weight;
        weight_sum += weight;
    }

    vec3 result = color_sum / weight_sum;
    imageStore(out_denoised, pixel, vec4(result, color_center.a));
}
