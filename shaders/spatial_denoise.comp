#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int object_shadow_quality;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int taa_quality;
} pc;

layout(SET_BINDING(0, 0)) uniform sampler2D gbuffer_linear_depth;
layout(SET_BINDING(0, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(0, 2)) uniform sampler2D lit_color_input;

layout(rgba8, SET_BINDING(1, 0)) writeonly uniform image2D out_denoised;

const float GOLDEN_ANGLE = 2.399963229728653;
const int SAMPLE_COUNT = 8;
const float SAMPLE_RADIUS = 3.0;
const float DEPTH_THRESHOLD = 0.05;

/* Bloom constants for emissive glow */
const float BLOOM_THRESHOLD = 1.2;
const float BLOOM_INTENSITY = 0.15;
const float BLOOM_RADIUS = 6.0;
const int BLOOM_SAMPLES = 8;
const int DEBUG_DENOISE_RAW = 14;
const int DEBUG_DENOISE_DIFF = 15;
const float DEBUG_DENOISE_DIFF_SCALE = 4.0;

float luminance(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

vec2 get_poisson_sample(int i, float rotation) {
    float r = sqrt(float(i + 1) / float(SAMPLE_COUNT + 1));
    float theta = float(i) * GOLDEN_ANGLE + rotation;
    return vec2(cos(theta), sin(theta)) * r * SAMPLE_RADIUS;
}

vec2 get_bloom_sample(int i, float rotation) {
    float r = sqrt(float(i + 1) / float(BLOOM_SAMPLES + 1));
    float theta = float(i) * GOLDEN_ANGLE + rotation;
    return vec2(cos(theta), sin(theta)) * r * BLOOM_RADIUS;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(out_denoised);
    if (pixel.x >= size.x || pixel.y >= size.y)
        return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);

    float depth_center = texture(gbuffer_linear_depth, uv).r;
    vec3 normal_center = texture(gbuffer_normal, uv).rgb * 2.0 - 1.0;
    vec4 color_center = texture(lit_color_input, uv);

    /* DEBUG: Bypass denoise and show raw lit color */
    if (pc.debug_mode == DEBUG_DENOISE_RAW) {
        imageStore(out_denoised, pixel, color_center);
        return;
    }

    /* Sky pixels (depth=1.0) pass through unchanged */
    if (depth_center >= 0.9999) {
        imageStore(out_denoised, pixel, color_center);
        return;
    }

    /* Golden angle rotation per-pixel for temporal variance */
    float rotation = float(pc.frame_count) * GOLDEN_ANGLE + float(pixel.x * 73 + pixel.y * 137);

    vec3 color_sum = color_center.rgb;
    float weight_sum = 1.0;

    vec2 texel_size = 1.0 / vec2(size);

    for (int i = 0; i < SAMPLE_COUNT; i++) {
        vec2 offset = get_poisson_sample(i, rotation);
        vec2 sample_uv = uv + offset * texel_size;

        /* Clamp to valid range */
        sample_uv = clamp(sample_uv, vec2(0.0), vec2(1.0));

        float depth_sample = texture(gbuffer_linear_depth, sample_uv).r;
        vec3 normal_sample = texture(gbuffer_normal, sample_uv).rgb * 2.0 - 1.0;
        vec3 color_sample = texture(lit_color_input, sample_uv).rgb;

        /* Bilateral weights */
        float depth_diff = abs(depth_sample - depth_center);
        float depth_weight = exp(-depth_diff / DEPTH_THRESHOLD);

        float normal_dot = max(0.0, dot(normal_sample, normal_center));
        float normal_weight = step(0.9, normal_dot);

        float weight = depth_weight * normal_weight;

        color_sum += color_sample * weight;
        weight_sum += weight;
    }

    vec3 result = color_sum / weight_sum;

    /* Simple bloom pass: gather bright pixels (emissives) and add soft glow */
    vec3 bloom = vec3(0.0);
    float bloom_weight = 0.0;

    for (int i = 0; i < BLOOM_SAMPLES; i++) {
        vec2 offset = get_bloom_sample(i, rotation * 0.7);
        vec2 sample_uv = uv + offset * texel_size;
        sample_uv = clamp(sample_uv, vec2(0.0), vec2(1.0));

        vec3 sample_color = texture(lit_color_input, sample_uv).rgb;
        float sample_lum = luminance(sample_color);

        /* Only gather from bright (emissive) pixels */
        if (sample_lum > BLOOM_THRESHOLD) {
            float dist = length(offset);
            float falloff = 1.0 / (1.0 + dist * 0.5);
            vec3 excess = sample_color - vec3(BLOOM_THRESHOLD);
            bloom += max(excess, vec3(0.0)) * falloff;
            bloom_weight += falloff;
        }
    }

    /* Also check center pixel for self-glow */
    float center_lum = luminance(color_center.rgb);
    if (center_lum > BLOOM_THRESHOLD) {
        vec3 excess = color_center.rgb - vec3(BLOOM_THRESHOLD);
        bloom += max(excess, vec3(0.0)) * 2.0;
        bloom_weight += 2.0;
    }

    if (bloom_weight > 0.0) {
        result += bloom * BLOOM_INTENSITY;
    }

    /* DEBUG: Visualize denoise delta */
    if (pc.debug_mode == DEBUG_DENOISE_DIFF) {
        vec3 diff = abs(result - color_center.rgb) * DEBUG_DENOISE_DIFF_SCALE;
        imageStore(out_denoised, pixel, vec4(diff, 1.0));
        return;
    }

    imageStore(out_denoised, pixel, vec4(result, color_center.a));
}
