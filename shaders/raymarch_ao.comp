#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int object_shadow_quality;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int taa_quality;
} pc;

#include "include/gbuffer_sample.glsl"

ivec3 pc_grid_size;
ivec3 pc_chunks_dim;
int pc_total_chunks;

layout(std430, SET_BINDING(0, 0)) readonly buffer VoxelBuffer {
    uint voxel_data[];
};

layout(std430, SET_BINDING(0, 1)) readonly buffer ChunkHeaders {
    uvec4 chunk_headers[];
};

layout(SET_BINDING(0, 2)) uniform usampler3D shadow_volume_tex;

#include "include/data_terrain.glsl"

layout(SET_BINDING(1, 0)) uniform sampler2D gbuffer_depth;
layout(SET_BINDING(1, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(1, 2)) uniform sampler2D gbuffer_world_pos;
layout(SET_BINDING(1, 3)) uniform sampler2D blue_noise_tex;

layout(r8, SET_BINDING(2, 0)) writeonly uniform image2D out_ao;

const int BASE_AO_STEPS = 64;
const float AO_MAX_DIST = 3.0;

/* Shadow volume dimensions cached from grid_size (avoids per-sample textureSize calls) */
ivec3 ao_shadow_dim0;
ivec3 ao_shadow_dim1;
ivec3 ao_shadow_dim2;

vec3 world_to_grid(vec3 world_pos) {
    return (world_pos - pc.bounds_min) / pc.voxel_size;
}

bool sample_shadow_volume(ivec3 voxel_pos) {
    ivec3 shadow_pos = voxel_pos >> 1;

    if (shadow_pos.x < 0 || shadow_pos.x >= ao_shadow_dim0.x ||
        shadow_pos.y < 0 || shadow_pos.y >= ao_shadow_dim0.y ||
        shadow_pos.z < 0 || shadow_pos.z >= ao_shadow_dim0.z) {
        return false;
    }

    uint packed = texelFetch(shadow_volume_tex, shadow_pos, 0).r;
    int bit_idx = (voxel_pos.x & 1) + ((voxel_pos.y & 1) << 1) + ((voxel_pos.z & 1) << 2);
    return (packed & (1u << bit_idx)) != 0u;
}

bool sample_shadow_mip1(ivec3 voxel_pos) {
    ivec3 mip1_pos = voxel_pos >> 2;

    if (mip1_pos.x < 0 || mip1_pos.x >= ao_shadow_dim1.x ||
        mip1_pos.y < 0 || mip1_pos.y >= ao_shadow_dim1.y ||
        mip1_pos.z < 0 || mip1_pos.z >= ao_shadow_dim1.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip1_pos, 1).r != 0u;
}

bool sample_shadow_mip2(ivec3 voxel_pos) {
    ivec3 mip2_pos = voxel_pos >> 3;

    if (mip2_pos.x < 0 || mip2_pos.x >= ao_shadow_dim2.x ||
        mip2_pos.y < 0 || mip2_pos.y >= ao_shadow_dim2.y ||
        mip2_pos.z < 0 || mip2_pos.z >= ao_shadow_dim2.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip2_pos, 2).r != 0u;
}

float trace_ao_ray(vec3 origin, vec3 rd, int max_steps) {
    vec2 box_hit = hdda_intersect_aabb(origin, rd, pc.bounds_min, pc.bounds_max);
    if (box_hit.x > box_hit.y || box_hit.y < 0.0) {
        return 1.0;
    }

    float t_start = max(box_hit.x, 0.001);
    float t_end = min(box_hit.y, AO_MAX_DIST);

    if (t_start >= t_end) {
        return 1.0;
    }

    vec3 start_pos = origin + rd * t_start;
    vec3 grid_pos = world_to_grid(start_pos);
    grid_pos = clamp(grid_pos, vec3(0.0), vec3(pc.grid_size) - 0.001);

    ivec3 map_pos = ivec3(floor(grid_pos));
    vec3 delta_dist = abs(1.0 / rd);
    ivec3 step_dir = ivec3(sign(rd));
    vec3 side_dist = (sign(rd) * (vec3(map_pos) - grid_pos) + sign(rd) * 0.5 + 0.5) * delta_dist;

    ivec3 last_mip2_pos = ivec3(-1000);
    ivec3 last_mip1_pos = ivec3(-1000);
    bool mip2_empty = false;
    bool mip1_empty = false;

    /* Track parametric distance along ray to avoid length() per iteration.
       t_current tracks minimum side_dist which equals ray parameter. */
    float t_current = t_start;

    for (int i = 0; i < max_steps; i++) {
        if (map_pos.x < 0 || map_pos.x >= pc.grid_size.x ||
            map_pos.y < 0 || map_pos.y >= pc.grid_size.y ||
            map_pos.z < 0 || map_pos.z >= pc.grid_size.z) {
            return 1.0;
        }

        /* Early exit based on parametric distance (no sqrt needed) */
        if (t_current > AO_MAX_DIST) {
            return 1.0;
        }

        ivec3 current_mip2 = map_pos >> 3;
        if (current_mip2 != last_mip2_pos) {
            last_mip2_pos = current_mip2;
            mip2_empty = !sample_shadow_mip2(map_pos);
            last_mip1_pos = ivec3(-1000);
        }

        if (mip2_empty) {
            /* Skip to mip2 boundary along the DDA exit axis */
            ivec3 mip2_min = current_mip2 << 3;
            ivec3 mip2_max = mip2_min + 7;
            ivec3 cells_to_exit;
            cells_to_exit.x = (step_dir.x > 0) ? (mip2_max.x - map_pos.x + 1) : (map_pos.x - mip2_min.x + 1);
            cells_to_exit.y = (step_dir.y > 0) ? (mip2_max.y - map_pos.y + 1) : (map_pos.y - mip2_min.y + 1);
            cells_to_exit.z = (step_dir.z > 0) ? (mip2_max.z - map_pos.z + 1) : (map_pos.z - mip2_min.z + 1);
            vec3 t_exit = side_dist + vec3(cells_to_exit - 1) * delta_dist;
            bvec3 mask = lessThanEqual(t_exit.xyz, min(t_exit.yzx, t_exit.zxy));
            ivec3 skip_per_axis = ivec3(mask) * cells_to_exit;
            int skip = skip_per_axis.x + skip_per_axis.y + skip_per_axis.z;
            map_pos += ivec3(mask) * step_dir * cells_to_exit;
            side_dist += vec3(skip_per_axis) * delta_dist;
            t_current = min(min(side_dist.x, side_dist.y), side_dist.z);
            i += max(skip - 1, 0);
            continue;
        }

        ivec3 current_mip1 = map_pos >> 2;
        if (current_mip1 != last_mip1_pos) {
            last_mip1_pos = current_mip1;
            mip1_empty = !sample_shadow_mip1(map_pos);
        }

        if (mip1_empty) {
            /* Skip to mip1 boundary along the DDA exit axis */
            ivec3 mip1_min = current_mip1 << 2;
            ivec3 mip1_max = mip1_min + 3;
            ivec3 cells_to_exit;
            cells_to_exit.x = (step_dir.x > 0) ? (mip1_max.x - map_pos.x + 1) : (map_pos.x - mip1_min.x + 1);
            cells_to_exit.y = (step_dir.y > 0) ? (mip1_max.y - map_pos.y + 1) : (map_pos.y - mip1_min.y + 1);
            cells_to_exit.z = (step_dir.z > 0) ? (mip1_max.z - map_pos.z + 1) : (map_pos.z - mip1_min.z + 1);
            vec3 t_exit = side_dist + vec3(cells_to_exit - 1) * delta_dist;
            bvec3 mask = lessThanEqual(t_exit.xyz, min(t_exit.yzx, t_exit.zxy));
            ivec3 skip_per_axis = ivec3(mask) * cells_to_exit;
            int skip = skip_per_axis.x + skip_per_axis.y + skip_per_axis.z;
            map_pos += ivec3(mask) * step_dir * cells_to_exit;
            side_dist += vec3(skip_per_axis) * delta_dist;
            t_current = min(min(side_dist.x, side_dist.y), side_dist.z);
            i += max(skip - 1, 0);
            continue;
        }

        if (sample_shadow_volume(map_pos)) {
            /* Only compute exact distance on HIT */
            float ao = t_current / AO_MAX_DIST;
            return ao;
        }

        bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
        side_dist += vec3(mask) * delta_dist;
        map_pos += ivec3(mask) * step_dir;
        t_current = min(min(side_dist.x, side_dist.y), side_dist.z);
    }

    return 1.0;
}

vec3 cosine_weighted_hemisphere(vec2 xi, vec3 N) {
    float phi = 2.0 * 3.14159265 * xi.y;
    float cos_theta = sqrt(1.0 - xi.x);
    float sin_theta = sqrt(xi.x);

    vec3 local_dir = vec3(
        cos(phi) * sin_theta,
        sin(phi) * sin_theta,
        cos_theta
    );

    vec3 up = abs(N.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return tangent * local_dir.x + bitangent * local_dir.y + N * local_dir.z;
}

void main() {
    pc_grid_size = pc.grid_size;
    pc_chunks_dim = pc.chunks_dim;
    pc_total_chunks = pc.total_chunks;

    /* Cache shadow volume dimensions (computed from grid_size, avoids textureSize calls) */
    ao_shadow_dim0 = (pc.grid_size + 1) >> 1;
    ao_shadow_dim1 = (pc.grid_size + 3) >> 2;
    ao_shadow_dim2 = (pc.grid_size + 7) >> 3;

    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(out_ao);

    if (pixel.x >= screen_size.x || pixel.y >= screen_size.y) {
        return;
    }

    GBufferSample g = sample_gbuffer_shadow(
        pixel,
        gbuffer_depth, gbuffer_normal, gbuffer_world_pos
    );

    if (g.is_sky) {
        imageStore(out_ao, pixel, vec4(1.0));
        return;
    }

    vec3 normal = normalize(g.normal);

    /* Quality 0 = disabled (return full visibility) */
    if (pc.ao_quality == 0) {
        imageStore(out_ao, pixel, vec4(1.0));
        return;
    }

    /* Distance-based AO step scaling: close surfaces need fewer steps */
    float surface_dist = length(g.world_pos - pc.camera_pos);
    int ao_steps = BASE_AO_STEPS;
    if (surface_dist < 15.0) {
        ao_steps = 32;   /* Close: half steps */
    } else if (surface_dist < 40.0) {
        ao_steps = 48;   /* Mid: 75% steps */
    }

    vec2 noise_uv = vec2(pixel) / 128.0;
    float spatial_noise = texture(blue_noise_tex, noise_uv).r;
    float temporal_offset = float(pc.frame_count) * 0.6180339887;

    float bias = pc.voxel_size * 0.4;
    vec3 ao_origin = g.world_pos + normal * bias;

     /* Quality-scaled samples: Fair=1, Good=2, High=4 samples per pixel
         Temporal accumulation smooths out noise over frames.
         Close surfaces use fewer samples since temporal handles noise well. */
     int base_samples = (pc.ao_quality <= 1) ? 1 : (pc.ao_quality == 2 ? 2 : 4);
     int num_samples = base_samples;
     if (surface_dist < 10.0 && base_samples > 1) {
         num_samples = max(base_samples - 1, 1);  /* Close: reduce by 1 */
     }
    float ao_sum = 0.0;

    for (int s = 0; s < num_samples; s++) {
        float noise = fract(spatial_noise + temporal_offset + float(s) * 0.5);
        float noise2 = fract(spatial_noise * 1.618 + temporal_offset + float(s) * 0.309);

        vec2 xi = vec2(noise, noise2);

        vec3 ao_dir = cosine_weighted_hemisphere(xi, normal);

        ao_sum += trace_ao_ray(ao_origin, ao_dir, ao_steps);
    }

    float ao = ao_sum / float(num_samples);

    imageStore(out_ao, pixel, vec4(ao, 0.0, 0.0, 0.0));
}
