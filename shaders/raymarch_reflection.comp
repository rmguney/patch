#version 450

#if defined(PATCH_VULKAN)
#define SET_BINDING(set_, binding_) set = set_, binding = binding_
#else
#define SET_BINDING(set_, binding_) binding = binding_
#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(push_constant) uniform Constants {
    mat4 inv_view;
    mat4 inv_projection;
    vec3 bounds_min;
    float voxel_size;
    vec3 bounds_max;
    float chunk_size;
    vec3 camera_pos;
    int history_valid;
    ivec3 grid_size;
    int total_chunks;
    ivec3 chunks_dim;
    int frame_count;
    int _pad0;
    int debug_mode;
    int is_orthographic;
    int max_steps;
    float near_plane;
    float far_plane;
    int object_count;
    int shadow_quality;
    int shadow_contact;
    int ao_quality;
    int lod_quality;
    int reflection_quality;
} pc;

#include "include/camera.glsl"

ivec3 pc_grid_size;
ivec3 pc_chunks_dim;
int pc_total_chunks;

/* Set 0: Voxel data + shadow volume + materials */
layout(std430, SET_BINDING(0, 0)) readonly buffer VoxelBuffer {
    uint voxel_data[];
};

layout(std430, SET_BINDING(0, 1)) readonly buffer ChunkHeaders {
    uvec4 chunk_headers[];
};

layout(SET_BINDING(0, 2)) uniform usampler3D shadow_volume_tex;

layout(std140, SET_BINDING(0, 3)) uniform MaterialPalette {
    vec4 materials[512];
};

#include "include/materials.glsl"
#include "include/data_terrain.glsl"

/* Set 1: G-buffer inputs */
layout(SET_BINDING(1, 0)) uniform sampler2D gbuffer_depth;
layout(SET_BINDING(1, 1)) uniform sampler2D gbuffer_normal;
layout(SET_BINDING(1, 2)) uniform sampler2D gbuffer_albedo;
layout(SET_BINDING(1, 3)) uniform sampler2D gbuffer_material;
layout(SET_BINDING(1, 4)) uniform sampler2D blue_noise_tex;
layout(SET_BINDING(1, 5)) uniform sampler2D gbuffer_world_pos;
layout(std140, SET_BINDING(1, 6)) uniform TemporalUBO {
    mat4 prev_view_proj;
    mat4 view_proj;
};

/* Set 2: Output */
layout(rgba8, SET_BINDING(2, 0)) writeonly uniform image2D out_reflection;

const float REFLECTION_MAX_DIST = 50.0;
const vec3 SKY_COLOR = vec3(0.6, 0.75, 0.95);
const float SSR_UV_MARGIN = 0.05;

/* Quality-scaled max steps: 1=64, 2=128, 3=192 */
int get_max_reflection_steps() {
    return 64 * pc.reflection_quality;
}

vec3 world_to_grid(vec3 world_pos) {
    return (world_pos - pc.bounds_min) / pc.voxel_size;
}

bool sample_shadow_volume(ivec3 voxel_pos) {
    ivec3 shadow_pos = voxel_pos >> 1;
    ivec3 shadow_size = textureSize(shadow_volume_tex, 0);

    if (shadow_pos.x < 0 || shadow_pos.x >= shadow_size.x ||
        shadow_pos.y < 0 || shadow_pos.y >= shadow_size.y ||
        shadow_pos.z < 0 || shadow_pos.z >= shadow_size.z) {
        return false;
    }

    uint packed = texelFetch(shadow_volume_tex, shadow_pos, 0).r;
    int bit_idx = (voxel_pos.x & 1) + ((voxel_pos.y & 1) << 1) + ((voxel_pos.z & 1) << 2);
    return (packed & (1u << bit_idx)) != 0u;
}

bool sample_shadow_mip1(ivec3 voxel_pos) {
    ivec3 mip1_pos = voxel_pos >> 2;
    ivec3 mip1_size = textureSize(shadow_volume_tex, 1);

    if (mip1_pos.x < 0 || mip1_pos.x >= mip1_size.x ||
        mip1_pos.y < 0 || mip1_pos.y >= mip1_size.y ||
        mip1_pos.z < 0 || mip1_pos.z >= mip1_size.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip1_pos, 1).r != 0u;
}

bool sample_shadow_mip2(ivec3 voxel_pos) {
    ivec3 mip2_pos = voxel_pos >> 3;
    ivec3 mip2_size = textureSize(shadow_volume_tex, 2);

    if (mip2_pos.x < 0 || mip2_pos.x >= mip2_size.x ||
        mip2_pos.y < 0 || mip2_pos.y >= mip2_size.y ||
        mip2_pos.z < 0 || mip2_pos.z >= mip2_size.z) {
        return false;
    }

    return texelFetch(shadow_volume_tex, mip2_pos, 2).r != 0u;
}

/* Fresnel-Schlick approximation */
vec3 fresnel_schlick(float cos_theta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0);
}

/* Sample material color from voxel grid at hit position.
   Returns sky color if no material (e.g., hit object/particle not in terrain data). */
vec3 sample_hit_color(ivec3 map_pos) {
    uint mat = sample_material(map_pos);
    if (mat == 0u) {
        return SKY_COLOR; /* No terrain material at this position */
    }
    return get_material_color(mat);
}

/* Trace reflection ray, returns hit color and distance */
struct ReflectionHit {
    vec3 color;
    float dist;
    bool hit;
};

ReflectionHit trace_reflection_ray(vec3 origin, vec3 rd) {
    ReflectionHit result;
    result.hit = false;
    result.color = SKY_COLOR;
    result.dist = REFLECTION_MAX_DIST;

    vec2 box_hit = hdda_intersect_aabb(origin, rd, pc.bounds_min, pc.bounds_max);
    if (box_hit.x > box_hit.y || box_hit.y < 0.0) {
        return result;
    }

    float t_start = max(box_hit.x, 0.001);
    float t_end = min(box_hit.y, REFLECTION_MAX_DIST);

    if (t_start >= t_end) {
        return result;
    }

    vec3 start_pos = origin + rd * t_start;
    vec3 grid_pos = world_to_grid(start_pos);
    grid_pos = clamp(grid_pos, vec3(0.0), vec3(pc.grid_size) - 0.001);

    ivec3 map_pos = ivec3(floor(grid_pos));
    vec3 delta_dist = abs(1.0 / rd);
    ivec3 step_dir = ivec3(sign(rd));
    vec3 side_dist = (sign(rd) * (vec3(map_pos) - grid_pos) + sign(rd) * 0.5 + 0.5) * delta_dist;

    /* DEBUG: Increased max steps since we disabled hierarchical skip */
    int max_steps = 512;
    for (int i = 0; i < max_steps; i++) {
        if (map_pos.x < 0 || map_pos.x >= pc.grid_size.x ||
            map_pos.y < 0 || map_pos.y >= pc.grid_size.y ||
            map_pos.z < 0 || map_pos.z >= pc.grid_size.z) {
            return result;
        }

        vec3 hit_grid = vec3(map_pos) + 0.5;
        vec3 hit_world = pc.bounds_min + hit_grid * pc.voxel_size;
        float dist = length(hit_world - origin);
        if (dist > REFLECTION_MAX_DIST) {
            return result;
        }

        /* Hierarchical skip using shadow volume mips */
        bool mip2_empty = !sample_shadow_mip2(map_pos);
        if (mip2_empty) {
            bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
            side_dist += vec3(mask) * delta_dist;
            map_pos += ivec3(mask) * step_dir;
            continue;
        }

        bool mip1_empty = !sample_shadow_mip1(map_pos);
        if (mip1_empty) {
            bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
            side_dist += vec3(mask) * delta_dist;
            map_pos += ivec3(mask) * step_dir;
            continue;
        }

        /* Use terrain material data directly for hit detection instead of shadow volume.
           Skip hits within 1.5 voxels of origin to prevent self-intersection. */
        uint mat = sample_material(map_pos);
        if (mat != 0u && dist > pc.voxel_size * 1.5) {
            result.hit = true;
            result.color = get_material_color(mat);
            result.dist = dist;
            return result;
        }

        bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
        side_dist += vec3(mask) * delta_dist;
        map_pos += ivec3(mask) * step_dir;
    }

    return result;
}

bool project_world_to_uv(vec3 world_pos, out vec2 uv) {
    vec4 clip = view_proj * vec4(world_pos, 1.0);
    float w = max(abs(clip.w), 1e-4);
    vec2 ndc = clip.xy / w;
    if (clip.w < 0.0) {
        ndc = -ndc;
    }
    uv = ndc * 0.5 + 0.5;
    if (uv.x < -SSR_UV_MARGIN || uv.x > 1.0 + SSR_UV_MARGIN ||
        uv.y < -SSR_UV_MARGIN || uv.y > 1.0 + SSR_UV_MARGIN) {
        return false;
    }
    uv = clamp(uv, vec2(0.0), vec2(1.0));
    return true;
}

bool trace_reflection_ssr(vec3 origin, vec3 rd, ivec2 screen_size, out vec3 out_color, out float out_dist) {
    int max_steps = 16 * pc.reflection_quality;
    float step_len = pc.voxel_size * 2.0;
    float t = step_len;

    for (int i = 0; i < max_steps; i++) {
        if (t > REFLECTION_MAX_DIST) {
            break;
        }

        vec3 ray_pos = origin + rd * t;
        vec2 uv;
        if (!project_world_to_uv(ray_pos, uv)) {
            break;
        }

        ivec2 sample_px = ivec2(uv * vec2(screen_size));
        sample_px = clamp(sample_px, ivec2(0), screen_size - ivec2(1));

        float depth = texelFetch(gbuffer_depth, sample_px, 0).r;
        if (depth > 1e9) {
            t += step_len;
            continue;
        }

        vec3 gpos = texelFetch(gbuffer_world_pos, sample_px, 0).xyz;
        float hit_dist = length(gpos - ray_pos);
        if (hit_dist <= pc.voxel_size * 1.5) {
            out_color = texelFetch(gbuffer_albedo, sample_px, 0).rgb;
            out_dist = length(gpos - origin);
            return true;
        }

        t += step_len;
    }

    return false;
}

/* Generate roughness-based cone jitter direction */
vec3 jitter_reflection(vec3 reflect_dir, float roughness, vec2 noise) {
    if (roughness < 0.01) {
        return reflect_dir;
    }

    vec3 up = abs(reflect_dir.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, reflect_dir));
    vec3 bitangent = cross(reflect_dir, tangent);

    float cone_angle = roughness * roughness * 0.5;
    float phi = 2.0 * 3.14159265 * noise.x;
    float cos_theta = 1.0 - noise.y * cone_angle;
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    vec3 local_dir = vec3(
        cos(phi) * sin_theta,
        sin(phi) * sin_theta,
        cos_theta
    );

    return normalize(tangent * local_dir.x + bitangent * local_dir.y + reflect_dir * local_dir.z);
}

void main() {
    pc_grid_size = pc.grid_size;
    pc_chunks_dim = pc.chunks_dim;
    pc_total_chunks = pc.total_chunks;

    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(out_reflection);

    if (pixel.x >= screen_size.x || pixel.y >= screen_size.y) {
        return;
    }

    /* Early out if reflections disabled */
    if (pc.reflection_quality == 0) {
        imageStore(out_reflection, pixel, vec4(0.0, 0.0, 0.0, 0.0));
        return;
    }

    /* Sample G-buffer */
    vec2 uv = (vec2(pixel) + 0.5) / vec2(screen_size);
    float linear_depth = texelFetch(gbuffer_depth, pixel, 0).r;

    bool is_sky = (linear_depth > 1e9);
    if (is_sky) {
        imageStore(out_reflection, pixel, vec4(0.0, 0.0, 0.0, 0.0));
        return;
    }

    /* Decode normal and snap near-axis components to reduce quantization noise.
       RGB8 storage causes Â±0.004 error on zero components, which creates grazing angle flicker. */
    vec3 raw_normal = texelFetch(gbuffer_normal, pixel, 0).rgb * 2.0 - 1.0;
    vec3 normal = normalize(vec3(
        abs(raw_normal.x) < 0.01 ? 0.0 : raw_normal.x,
        abs(raw_normal.y) < 0.01 ? 0.0 : raw_normal.y,
        abs(raw_normal.z) < 0.01 ? 0.0 : raw_normal.z
    ));
    vec3 albedo = texelFetch(gbuffer_albedo, pixel, 0).rgb;
    vec4 material = texelFetch(gbuffer_material, pixel, 0);
    float roughness = material.r;
    float metallic = material.g;

    /* Sample world position from G-buffer (stored directly, no reconstruction needed) */
    vec3 world_pos = texelFetch(gbuffer_world_pos, pixel, 0).xyz;

    /* Calculate view direction */
    vec3 V = (pc.is_orthographic != 0)
        ? -normalize((pc.inv_view * vec4(0.0, 0.0, -1.0, 0.0)).xyz)
        : normalize(pc.camera_pos - world_pos);
    float NdotV = max(dot(normal, V), 0.0);

    /* Fresnel: F0 = mix(0.04, albedo, metallic) */
    vec3 F0 = mix(vec3(0.04), albedo, metallic);
    vec3 fresnel = fresnel_schlick(NdotV, F0);

    /* Skip very rough or non-reflective surfaces
       Quality scales roughness threshold: 1=0.7, 2=0.85, 3=0.95 (widened for visibility) */
    float max_roughness = 0.55 + 0.15 * float(pc.reflection_quality);
    float reflectivity = max(max(fresnel.r, fresnel.g), fresnel.b);
    /* Soft falloff instead of hard threshold to prevent grazing angle flicker */
    float roughness_atten = 1.0 - smoothstep(max_roughness - 0.1, max_roughness, roughness);
    reflectivity *= roughness_atten;
    if (reflectivity < 0.005) {
        imageStore(out_reflection, pixel, vec4(0.0, 0.0, 0.0, 0.0));
        return;
    }

    /* Calculate reflection direction */
    vec3 reflect_dir = reflect(-V, normal);

    /* No jitter - use mirror reflections. Glossy blur via jitter caused flickering
       that temporal accumulation couldn't smooth. Sharp reflections look better
       for voxel aesthetics anyway. */
    vec3 jittered_dir = reflect_dir;

    /* At grazing angles (NdotV small), aggressive normal bias prevents self-intersection.
       The reflect_dir is nearly parallel to surface at grazing - biasing along it doesn't help.
       Instead, push the ray origin away from the surface along the normal. */
    float grazing = 1.0 - NdotV; /* 0 at head-on, 1 at grazing */
    float normal_bias = pc.voxel_size * (0.4 + grazing * grazing * 2.0); /* 0.4 to 2.4 */
    float reflect_bias = pc.voxel_size * 0.5;
    vec3 ray_origin = world_pos + reflect_dir * reflect_bias + normal * normal_bias;

    /* Trace reflection ray: SSR first (reuses G-buffer), fallback to terrain DDA */
    ReflectionHit hit;
    vec3 ssr_color = SKY_COLOR;
    float ssr_dist = REFLECTION_MAX_DIST;
    if (trace_reflection_ssr(ray_origin, jittered_dir, screen_size, ssr_color, ssr_dist)) {
        hit.hit = true;
        hit.color = ssr_color;
        hit.dist = ssr_dist;
    } else {
        hit = trace_reflection_ray(ray_origin, jittered_dir);
    }

    /* Calculate blend weight based on fresnel and roughness.
       Fade out at extreme grazing angles to hide remaining self-intersection artifacts.
       Wide smoothstep range (0.05-0.25) prevents flicker from NdotV quantization noise. */
    float roughness_fade = 1.0 - roughness * roughness;
    float grazing_fade = smoothstep(0.05, 0.25, NdotV);
    float blend_weight = reflectivity * roughness_fade * grazing_fade;

    /* Output: RGB = reflection color weighted by fresnel, A = blend weight */
    vec3 reflection_color = hit.color * fresnel;

    imageStore(out_reflection, pixel, vec4(reflection_color, blend_weight));
}
